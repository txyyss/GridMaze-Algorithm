\documentclass[cs4size,a4paper,adobefonts]{ctexart}
\usepackage{amsmath,amsthm,amssymb}
\usepackage[colorlinks=true,allcolors=black]{hyperref}
\usepackage{indentfirst}
\usepackage[a4paper,left=2.5cm,right=2.5cm,bottom=2.5cm,top=2.5cm]{geometry}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{url}
\usepackage{fontspec}
\setmainfont{Palatino}
\setmonofont[Scale=MatchLowercase]{Monaco}
\pagestyle{plain}
\punctstyle{kaiming}
\usepackage{unicode-math}
\setmathfont{Asana Math}

\newcommand{\GridMaze}{\href{http://itunes.apple.com/app/grid-maze/id553265800?mt=8}{Grid Maze}}
\graphicspath{{pic/}}

\begin{document}
\title{\bfseries 算法有什么用}
\author{\href{mailto:txyyss@gmail.com}{王盛颐}}
\date{}
\maketitle

\section*{缘起}
最近我的 iPad 程序 \GridMaze{} 在历经了 5 个月的开发，13 天的审核之后，
终于在苹果应用商店上架了。这个程序的主要功能是能根据输入的文字或图案，
生成一个迷宫，使得走出这个迷宫的唯一路径能形成当初输入的文字或图案。

生成这样一个迷宫的想法最早可以追溯到 2007 年底，不过那时完全不知道该怎
么做，于是这个想法也就是在脑子里徘徊了一阵，就置之一旁了。直到一年后也
就是 2008 年底，在看到一篇根据图形生成迷宫轮廓的文章
\cite{Xu:2007:ImageMaze}时，我突然想明白该怎么做了，于是就用
Mathematica 做了一些试验验证了我的想法，之后就一边完善想法一边写程序，
直到做出了一个以我名字为解法的迷宫。这个原型程序也就因为目标已达成而被
束之高阁。2010年，在朋友的鼓励下，我用 Qt 写了这个迷宫生成程序的界面，
同时用 C++ 重写了原先用 Java 和 Mathematica 写的部分，完善了一些功能，
这就是
\href{https://sites.google.com/site/txyyss/projects/text-maze-creator}{Text
  Maze Creator}。这个程序依赖一个第三方的 TSP 求解程序和一个
ActionScript 的编译器，操作起来很复杂，所以也没有提供下载，只是放了一些
样例在网上。转眼就到了2012 年，由于陆续能收到请求生成迷宫的邮件，我决定
写一个大家都能用的迷宫生成程序。我重新设计了界面，自己写了 TSP 的求解算
法，这才有了 iPad 上的 \GridMaze。

在开发 \GridMaze{} 的过程中，我遇到了很多有意思的问题，为了解决这些问题
参考和设计了很多算法。我觉得有必要把这些问题和解决办法整理一番，也算是
在初步完成这个项目之后，做一个总结报告。

\section{概述}
名不正则言不顺，言不顺则事不成。我先明确一下要解决的问题：生成一个迷宫，
使得走出这个迷宫的唯一路径能形成指定的文字或图案。这句话不够精确，需要
进一步的解释来消除歧义。

首先是“迷宫”的意思。本文的迷宫专指一种需要玩家从一个指定的起点出发，在
用墙隔断形成的分叉道路中辨识选择，最终到达指定终点的游戏。这样的迷宫具
有很多种形式（图 \ref{fig:manyMazes}），我要生成的迷宫是外轮廓为矩形，
分叉道路横平竖直，每一段墙的长度为单位长度整数倍的，解法唯一的所谓“标准
迷宫”（图 \ref{fig:rectMaze}）。

\begin{figure}[htbp]
  \centering
  \begin{subfigure}[c]{0.31\textwidth}
    \centering
    \includegraphics[width=\textwidth]{rectMaze}
    \caption{标准迷宫}\label{fig:rectMaze}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.31\textwidth}
    \centering
    \includegraphics[width=\textwidth]{diskMaze}
    \caption{圆形迷宫}\label{fig:diskMaze}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.31\textwidth}
    \centering
    \includegraphics[width=\textwidth]{eulerMaze}
    \caption{一笔画迷宫}
  \end{subfigure}
  \caption{各种不同类型的迷宫}\label{fig:manyMazes}
\end{figure}

接下来定义什么叫“路径形成指定的文字或图案”。我将文字或图案变成点阵（如
  图 \ref{fig:abcGrid}），如果有条路径能把这个点阵串起来，并且这条路径
上只遗漏了少量点阵中的点，只增加了少量不在这个点阵中的点。那么就可以说
路径形成了指定的文字或图案（如图 \ref{fig:abcPath}）。当然，由于这条路
径还要是“标准迷宫”的解答路径，所以还必须加上横平竖直，自身无交叉两个额
外的条件。

\begin{figure}[htbp]
  \centering
  \begin{minipage}{0.5\textwidth}
    \centering
    \includegraphics[width=0.95\linewidth]{abcGrid}
    \caption{文字点阵}\label{fig:abcGrid}
  \end{minipage}%
  \begin{minipage}{0.5\textwidth}
    \centering
    \includegraphics[width=0.95\linewidth]{abcPath}
    \caption{路径形成的文字}\label{fig:abcPath}
  \end{minipage}
\end{figure}

在明确了这两点之后，要解决的问题就清楚了。首先要根据点阵生成解答路径，
其次要根据解答路径生成迷宫。通过进一步的思考我发现，生成路径这个问题比
生成迷宫要困难得多。本着先易后难的原则，下面我先介绍如何根据已有的解答
路径，生成迷宫。

\section{迷宫生成算法}
生成迷宫有许多种算法 \cite{wiki:mazeGen}。我用的是基于图论的生成方法。
从一组预先安排好的互相隔断的格子布局开始，从这布局可以定义一个无向图
$G=(V,E)$，结点集合 $V$ 就是全部的格子，边的集合 $E$ 定义如下：若格子
$a,b$ 位于一堵墙的两侧，则 $\{a,b\}\in E$。

对任意 $F\subset E$，图 $G$ 的子图 $S=(V,F)$ 都对应一个迷宫，反之亦然。
具体对应方法如下：在原来布局的基础上，若 $e\in F$，则拆掉边 $e$ 对应的
那堵墙，也就是说 $S$ 的边意味着迷宫的通路。若 $S$ 不连通，那意味着对应
的迷宫有格子不可达，这显然不够理想。若 $S$ 中出现环路，则意味着迷宫的求
解路径可能不止一条，这也不理想。所以一个理想的迷宫对应的子图 $S$ 全连通
且无环，这正是图 $G$ 的支撑树 (Spanning Tree)。

\begin{figure}[htbp]
  \centering
  \begin{subfigure}[c]{0.31\textwidth}
    \centering
    \includegraphics[width=\textwidth]{rectCells}
    \caption{标准迷宫的格子布局}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.31\textwidth}
    \centering
    \includegraphics[width=\textwidth]{rectGraph}
    \caption{布局对应的无向图 $G$}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.31\textwidth}
    \centering
    \includegraphics[width=\textwidth]{rectMerged}
    \caption{将布局和图合并在一起}
  \end{subfigure}
  \caption{标准迷宫的布局和由它定义的无向图}\label{fig:rectMazeGen}
\end{figure}

到这里一个普通迷宫的生成算法就很显然了，任意计算支撑树的算法都可以。比
如随机 Kruskal 算法：
\begin{enumerate}
\item 创建一个全部墙的列表 $l$，给每个格子创建一个集合，该集合开始只包
  含那个格子一个元素
\item 乱序遍历 $l$，遍历时做如下操作：
  \begin{itemize}
  \item 若墙两边的格子属于一个集合，则不做任何操作
  \item 若强两边的格子不在一个集合里，则拆除这堵墙，合并两边格子所在的集合
  \end{itemize}
\end{enumerate}

\begin{figure}[htbp]
  \centering
  \begin{subfigure}[c]{0.31\textwidth}
    \centering
    \includegraphics[width=\textwidth]{diskCells}
    \caption{圆形迷宫的格子布局}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.31\textwidth}
    \centering
    \includegraphics[width=\textwidth]{diskGraph}
    \caption{布局对应的无向图 $G$}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.31\textwidth}
    \centering
    \includegraphics[width=\textwidth]{diskMerged}
    \caption{将布局和图合并在一起}
  \end{subfigure}
  \caption{圆形迷宫的布局和由它定义的无向图}\label{fig:diskMazeGen}
\end{figure}

图 \ref{fig:rectMaze} 中的标准迷宫和图 \ref{fig:diskMaze} 中的圆形迷宫
都是用随机 Kruskal 算法分别根据图 \ref{fig:rectMazeGen} 和图
\ref{fig:diskMazeGen} 中的布局生成的。有了这个算法，根据已有解答路径生
成迷宫变得轻而易举。只要把算法中 $l$ 的遍历顺序修改一下，先遍历解答路径
经过的那些墙，而后乱序遍历即可。

值得一提的是，随机 Kruskal 算法中，大量需要进行集合查找和集合合并的操作，
且这些集合彼此不相交。这可以用一种叫并查集 (Disjoint Sets) 的数据结构来
进行。这种数据结构单步进行查找或合并操作的时间复杂度几乎是常数，所以用
了这一数据结构的随机 Kruskal 算法的时间复杂度是 $O(n)$ 的，$n$ 是墙的数
量。关于 Disjoint Set 这里就不细说了，有兴趣的读者可查阅 \cite{clrs} 的
第 21 章。

\section{点阵连成路径的算法}
和生成迷宫相比，把点阵连成不自交的，横平竖直的路径要困难得多。下面将从
问题的进一步分析开始，逐步说明解决这一问题的方法。

\subsection{问题的进一步分析}

点阵的每个点都是坐标为整数的整点，如果把其中距离为 1 的点连起来，就形成
了一个格点图 (Grid Graph)。我们的问题就变成了能不能在这个格点图上找到指
定起始点的一条经过所有点而不自交的路径，也即所谓的哈密尔顿路径
(Hamiltonian path)。如果不能，那能不能通过添加或减少尽可能少的格点，使
之成为可能。非常遗憾，在一般的图上找哈密尔顿路径是 NP 完全的
\cite{Garey:1979:CIG:578533}，这正是把点阵连成求解路径这一问题困难所在。

在一般的图上找哈密尔顿路径是 NP 完全问题，现在要解决的问题并不是一般的
图，是格点图啊。它有很多良好的性质，比如它是平面图，是二分图，每个点的
度数不超过 4。在它上面找哈密尔顿路径是不是要简单些呢？早在 1982 年就有
人想过这个问题，并给出了否定的答案 \cite{citeulike:1905588}。到了 1997
年 Lenhart 等人倒是给出了多项式时间的在没有洞的格点图上找到哈密尔顿回路
的算法 \cite{Lenhart:1997:HCS:795663.796334}，但我的问题中的图不可避免
会有洞，所以这个结果还是对我没用。这里特别说明一下，一般的哈密尔顿路径
问题只要添加一个连接起始点的额外的点就能变成一个哈密尔顿回路问题，格点
图的话，无非添加若干格点也能同样转化。所以只要有哈密尔顿回路问题的解法
也就能解决哈密尔顿路径问题了。

理论上证明这是十分困难的 NP 完全问题了，那下面能想的就是近似解法。清华
大学 2011 年的文章 \cite{Zhang20115340} 给出了一类特殊的连通格点图上复
杂度为 $O(n^2)$ 的找哈密尔顿回路的近似解法，但还是不能解决一般格点图上
的问题。我还是只能采取 2008 年想到的办法：先求一个 TSP 近似解，然后局部
修正。

TSP(Travelling Salesman Problem) 是旅行推销员问题的意思，它是组合优化中
赫赫有名的一个 NP-hard 问题 \cite{wiki:TSP}。TSP 可以定义成在一个无向带
权图中找一条遍历所有结点的回路或路径，使得这条回路或路径上边的权重之和
最小。如果这个图的结点是平面上的点，图是所有点的完全图，而边的权重是边
连接的两个点之间的欧氏距离，这种特殊的 TSP 可称为欧几里德
TSP(Euclidean TSP)，它纯由平面上的点决定。如果格点图上存在哈密尔顿路径，
那么这条路径也是由这些格点决定的欧几里德 TSP 的解路径，因为不可能由比长
度 $n-1$ 更短的连接 $n$ 个格点的路径了。反之则未必，因为欧几里德 TSP 并
不能保证解路径一定横平竖直（不自交是显然的）。若欧氏 TSP 的解不是横平竖
直，那说明肯定不存在哈密尔顿路径了，但通常可以通过局部修正这个解路径，
也即增删点的方法，让这个解路径横平竖直而成为我们要求的用于生成迷宫的解
答路径。

有了上面的认识，算法就有了：近似求解 TSP 问题，修正解路径。若修正不成功，
则对问题做微小扰动然后重复“求解、修正”的循环，直到找到横平竖直的路径为
止。从实践看，这个算法还是能结束的。

\bibliographystyle{unsrt}
\bibliography{algorithm}
\end{document}
